// // utils/dataSchemas.js
// export const DataSchemas = {
//   // Check-in data structure
//   checkin: {
//     id: null, // Auto-generated by IndexedDB
//     employeeId: null,
//     checkinLatitude: null,
//     checkinLongitude: null,
//     checkinTime: null,
//     locationId: null,
//     farmId: null,
//     syncStatus: "pending", // 'pending', 'syncing', 'synced', 'failed'
//     timestamp: null, // When stored in IndexedDB
//     retryCount: 0,
//     lastError: null,
//     serverCheckinId: null, // ID returned from server after successful sync
//   },

//   // Form submission data structure
//   formSubmission: {
//     id: null, // Auto-generated by IndexedDB
//     employeeId: null,
//     locationId: null,
//     farmId: null,
//     checkinId: null, // Reference to local checkin ID
//     serverCheckinId: null, // Reference to server checkin ID
//     remark: null,
//     categoryDetails: [], // Array of category details
//     checklistItems: [], // Array of selected checklist item IDs
//     syncStatus: "pending",
//     timestamp: null,
//     retryCount: 0,
//     lastError: null,
//     serverFormDetailId: null, // ID returned from server after successful sync
//   },

//   // Checkout data structure
//   checkout: {
//     id: null, // Auto-generated by IndexedDB
//     employeeId: null,
//     checkoutLatitude: null,
//     checkoutLongitude: null,
//     checkoutTime: null,
//     checkinId: null, // Reference to local checkin ID
//     serverCheckinId: null, // Reference to server checkin ID
//     formDetailId: null, // Reference to form submission
//     syncStatus: "pending",
//     timestamp: null,
//     retryCount: 0,
//     lastError: null,
//   },

//   // Image data structure
//   image: {
//     id: null, // Auto-generated by IndexedDB
//     formSubmissionId: null, // Reference to local form submission
//     serverFormDetailId: null, // Reference to server form detail
//     categoryId: null,
//     subCategoryId: null,
//     fileName: null,
//     fileData: null, // Base64 or Blob
//     fileType: null,
//     fileSize: null,
//     syncStatus: "pending",
//     timestamp: null,
//     retryCount: 0,
//     lastError: null,
//   },

//   // Sync queue item structure
//   syncQueueItem: {
//     id: null, // Auto-generated by IndexedDB
//     type: null, // 'checkin', 'form', 'checkout', 'image'
//     dataId: null, // Reference to the actual data record
//     priority: 1, // 1 = high, 2 = medium, 3 = low
//     status: "pending", // 'pending', 'processing', 'completed', 'failed'
//     timestamp: null,
//     retryCount: 0,
//     lastAttempt: null,
//     lastError: null,
//   },
// };

// // utils/networkUtils.js
// export class NetworkUtils {
//   static isOnline() {
//     return navigator.onLine;
//   }

//   static async checkConnectivity() {
//     if (!navigator.onLine) {
//       return { isOnline: false, isSlowNetwork: false };
//     }

//     try {
//       // Test with a small request to your server
//       const startTime = Date.now();
//       const response = await fetch("/api/health-check", {
//         method: "HEAD",
//         cache: "no-cache",
//         timeout: 5000,
//       });
//       const endTime = Date.now();
//       const responseTime = endTime - startTime;

//       const isOnline = response.ok;
//       const isSlowNetwork = responseTime > 3000; // Consider >3s as slow

//       return { isOnline, isSlowNetwork, responseTime };
//     } catch (error) {
//       // If fetch fails, we're likely offline or have very poor connectivity
//       return { isOnline: false, isSlowNetwork: true, error: error.message };
//     }
//   }

//   static addNetworkListeners(callbacks) {
//     const handleOnline = () => {
//       console.log("Network: Online");
//       if (callbacks.onOnline) callbacks.onOnline();
//     };

//     const handleOffline = () => {
//       console.log("Network: Offline");
//       if (callbacks.onOffline) callbacks.onOffline();
//     };

//     window.addEventListener("online", handleOnline);
//     window.addEventListener("offline", handleOffline);

//     // Return cleanup function
//     return () => {
//       window.removeEventListener("online", handleOnline);
//       window.removeEventListener("offline", handleOffline);
//     };
//   }

//   static async testServerConnection(baseURL) {
//     try {
//       const response = await fetch(`${baseURL}/health`, {
//         method: "GET",
//         headers: {
//           "Content-Type": "application/json",
//         },
//         timeout: 5000,
//       });
//       return response.ok;
//     } catch (error) {
//       console.error("Server connection test failed:", error);
//       return false;
//     }
//   }
// }

// // utils/syncUtils.js
// export class SyncUtils {
//   static generateRetryDelay(retryCount) {
//     // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s
//     const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
//     // Add some jitter to avoid thundering herd
//     const jitter = Math.random() * 1000;
//     return delay + jitter;
//   }

//   static shouldRetry(retryCount, maxRetries = 5) {
//     return retryCount < maxRetries;
//   }

//   static createSyncQueueItem(type, dataId, priority = 2) {
//     return {
//       type,
//       dataId,
//       priority,
//       status: "pending",
//       timestamp: new Date().toISOString(),
//       retryCount: 0,
//       lastAttempt: null,
//       lastError: null,
//     };
//   }

//   static isSyncable(item) {
//     return item.syncStatus === "pending" || item.syncStatus === "failed";
//   }

//   static markAsSyncing(item) {
//     return {
//       ...item,
//       syncStatus: "syncing",
//       lastAttempt: new Date().toISOString(),
//     };
//   }

//   static markAsSynced(item, serverResponse = {}) {
//     return {
//       ...item,
//       syncStatus: "synced",
//       lastError: null,
//       ...serverResponse, // Merge any server-returned data
//     };
//   }

//   static markAsFailed(item, error) {
//     return {
//       ...item,
//       syncStatus: "failed",
//       retryCount: item.retryCount + 1,
//       lastError: error.message || "Unknown error",
//       lastAttempt: new Date().toISOString(),
//     };
//   }
// }

// // utils/storageUtils.js
// export class StorageUtils {
//   static async convertFileToBase64(file) {
//     return new Promise((resolve, reject) => {
//       const reader = new FileReader();
//       reader.onload = () => resolve(reader.result);
//       reader.onerror = reject;
//       reader.readAsDataURL(file);
//     });
//   }

//   static async convertBase64ToFile(base64Data, fileName, fileType) {
//     const response = await fetch(base64Data);
//     const blob = await response.blob();
//     return new File([blob], fileName, { type: fileType });
//   }

//   static calculateStorageUsage() {
//     if ("storage" in navigator && "estimate" in navigator.storage) {
//       return navigator.storage.estimate();
//     }
//     return null;
//   }

//   static async clearOldData(daysOld = 7) {
//     const cutoffDate = new Date();
//     cutoffDate.setDate(cutoffDate.getDate() - daysOld);
//     const cutoffTimestamp = cutoffDate.toISOString();

//     // This would be implemented to clean up old synced data
//     console.log(`Cleaning up data older than ${cutoffTimestamp}`);
//   }
// }
// utils/dataSchemas.js
// export const DataSchemas = {
//   // Check-in data structure
//   checkin: {
//     // id is auto-generated by IndexedDB, don't include it in the schema
//     employeeId: null,
//     checkinLatitude: null,
//     checkinLongitude: null,
//     checkinTime: null,
//     locationId: null,
//     farmId: null,
//     syncStatus: "pending", // 'pending', 'syncing', 'synced', 'failed'
//     timestamp: null, // When stored in IndexedDB
//     retryCount: 0,
//     lastError: null,
//     serverCheckinId: null, // ID returned from server after successful sync
//   },

//   // Form submission data structure
//   formSubmission: {
//     // id is auto-generated by IndexedDB
//     employeeId: null,
//     locationId: null,
//     farmId: null,
//     checkinId: null, // Reference to local checkin ID
//     serverCheckinId: null, // Reference to server checkin ID
//     remark: null,
//     categoryDetails: [], // Array of category details
//     checklistItems: [], // Array of selected checklist item IDs
//     syncStatus: "pending",
//     timestamp: null,
//     retryCount: 0,
//     lastError: null,
//     serverFormDetailId: null, // ID returned from server after successful sync
//   },

//   // Checkout data structure
//   checkout: {
//     // id is auto-generated by IndexedDB
//     employeeId: null,
//     checkoutLatitude: null,
//     checkoutLongitude: null,
//     checkoutTime: null,
//     checkinId: null, // Reference to local checkin ID
//     serverCheckinId: null, // Reference to server checkin ID
//     formDetailId: null, // Reference to form submission
//     syncStatus: "pending",
//     timestamp: null,
//     retryCount: 0,
//     lastError: null,
//   },

//   // Image data structure
//   image: {
//     // id is auto-generated by IndexedDB
//     formSubmissionId: null, // Reference to local form submission
//     serverFormDetailId: null, // Reference to server form detail
//     categoryId: null,
//     subCategoryId: null,
//     fileName: null,
//     fileData: null, // Base64 or Blob
//     fileType: null,
//     fileSize: null,
//     syncStatus: "pending",
//     timestamp: null,
//     retryCount: 0,
//     lastError: null,
//   },

//   // Sync queue item structure
//   syncQueueItem: {
//     // id is auto-generated by IndexedDB
//     type: null, // 'checkin', 'form', 'checkout', 'image'
//     dataId: null, // Reference to the actual data record
//     priority: 1, // 1 = high, 2 = medium, 3 = low
//     status: "pending", // 'pending', 'processing', 'completed', 'failed'
//     timestamp: null,
//     retryCount: 0,
//     lastAttempt: null,
//     lastError: null,
//   },
// };

// // utils/networkUtils.js
// export class NetworkUtils {
//   static isOnline() {
//     return navigator.onLine;
//   }

//   static async checkConnectivity() {
//     if (!navigator.onLine) {
//       return { isOnline: false, isSlowNetwork: false };
//     }

//     try {
//       // Test with a small request to your server
//       const startTime = Date.now();
//       const response = await fetch("/api/health-check", {
//         method: "HEAD",
//         cache: "no-cache",
//         timeout: 5000,
//       });
//       const endTime = Date.now();
//       const responseTime = endTime - startTime;

//       const isOnline = response.ok;
//       const isSlowNetwork = responseTime > 3000; // Consider >3s as slow

//       return { isOnline, isSlowNetwork, responseTime };
//     } catch (error) {
//       // If fetch fails, we're likely offline or have very poor connectivity
//       return { isOnline: false, isSlowNetwork: true, error: error.message };
//     }
//   }

//   static addNetworkListeners(callbacks) {
//     const handleOnline = () => {
//       console.log("Network: Online");
//       if (callbacks.onOnline) callbacks.onOnline();
//     };

//     const handleOffline = () => {
//       console.log("Network: Offline");
//       if (callbacks.onOffline) callbacks.onOffline();
//     };

//     window.addEventListener("online", handleOnline);
//     window.addEventListener("offline", handleOffline);

//     // Return cleanup function
//     return () => {
//       window.removeEventListener("online", handleOnline);
//       window.removeEventListener("offline", handleOffline);
//     };
//   }

//   static async testServerConnection(baseURL) {
//     try {
//       const response = await fetch(`${baseURL}/health`, {
//         method: "GET",
//         headers: {
//           "Content-Type": "application/json",
//         },
//         timeout: 5000,
//       });
//       return response.ok;
//     } catch (error) {
//       console.error("Server connection test failed:", error);
//       return false;
//     }
//   }
// }

// // utils/syncUtils.js
// export class SyncUtils {
//   static generateRetryDelay(retryCount) {
//     // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s
//     const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
//     // Add some jitter to avoid thundering herd
//     const jitter = Math.random() * 1000;
//     return delay + jitter;
//   }

//   static shouldRetry(retryCount, maxRetries = 5) {
//     return retryCount < maxRetries;
//   }

//   static createSyncQueueItem(type, dataId, priority = 2) {
//     return {
//       type,
//       dataId,
//       priority,
//       status: "pending",
//       timestamp: new Date().toISOString(),
//       retryCount: 0,
//       lastAttempt: null,
//       lastError: null,
//     };
//   }

//   static isSyncable(item) {
//     return item.syncStatus === "pending" || item.syncStatus === "failed";
//   }

//   static markAsSyncing(item) {
//     return {
//       ...item,
//       syncStatus: "syncing",
//       lastAttempt: new Date().toISOString(),
//     };
//   }

//   static markAsSynced(item, serverResponse = {}) {
//     return {
//       ...item,
//       syncStatus: "synced",
//       lastError: null,
//       ...serverResponse, // Merge any server-returned data
//     };
//   }

//   static markAsFailed(item, error) {
//     return {
//       ...item,
//       syncStatus: "failed",
//       retryCount: item.retryCount + 1,
//       lastError: error.message || "Unknown error",
//       lastAttempt: new Date().toISOString(),
//     };
//   }
// }

// // utils/storageUtils.js
// export class StorageUtils {
//   static async convertFileToBase64(file) {
//     return new Promise((resolve, reject) => {
//       const reader = new FileReader();
//       reader.onload = () => resolve(reader.result);
//       reader.onerror = reject;
//       reader.readAsDataURL(file);
//     });
//   }

//   static async convertBase64ToFile(base64Data, fileName, fileType) {
//     const response = await fetch(base64Data);
//     const blob = await response.blob();
//     return new File([blob], fileName, { type: fileType });
//   }

//   static calculateStorageUsage() {
//     if ("storage" in navigator && "estimate" in navigator.storage) {
//       return navigator.storage.estimate();
//     }
//     return null;
//   }

//   static async clearOldData(daysOld = 7) {
//     const cutoffDate = new Date();
//     cutoffDate.setDate(cutoffDate.getDate() - daysOld);
//     const cutoffTimestamp = cutoffDate.toISOString();

//     // This would be implemented to clean up old synced data
//     console.log(`Cleaning up data older than ${cutoffTimestamp}`);
//   }
// }

// utils/dataSchemas.js
export const DataSchemas = {
  // Check-in data structure
  checkin: {
    // id is auto-generated by IndexedDB, don't include it in the schema
    employeeId: null,
    checkinLatitude: null,
    checkinLongitude: null,
    checkinTime: null,
    locationId: null,
    farmId: null,
    syncStatus: "pending", // 'pending', 'syncing', 'synced', 'failed'
    timestamp: null, // When stored in IndexedDB
    retryCount: 0,
    lastError: null,
    serverCheckinId: null, // ID returned from server after successful sync
  },

  // Form submission data structure
  formSubmission: {
    // id is auto-generated by IndexedDB
    employeeId: null,
    locationId: null,
    farmId: null,
    checkinId: null, // Reference to local checkin ID
    serverCheckinId: null, // Reference to server checkin ID
    remark: null,
    categoryDetails: [], // Array of category details
    checklistItems: [], // Array of selected checklist item IDs
    syncStatus: "pending",
    timestamp: null,
    retryCount: 0,
    lastError: null,
    serverFormDetailId: null, // ID returned from server after successful sync
  },

  // Checkout data structure
  checkout: {
    // id is auto-generated by IndexedDB
    employeeId: null,
    checkoutLatitude: null,
    checkoutLongitude: null,
    checkoutTime: null,
    checkinId: null, // Reference to local checkin ID
    serverCheckinId: null, // Reference to server checkin ID
    formDetailId: null, // Reference to form submission
    syncStatus: "pending",
    timestamp: null,
    retryCount: 0,
    lastError: null,
  },

  // Image data structure
  image: {
    // id is auto-generated by IndexedDB
    formSubmissionId: null, // Reference to local form submission
    serverFormDetailId: null, // Reference to server form detail
    categoryId: null,
    subCategoryId: null,
    fileName: null,
    fileData: null, // Base64 or Blob
    fileType: null,
    fileSize: null,
    syncStatus: "pending",
    timestamp: null,
    retryCount: 0,
    lastError: null,
  },

  // New checkout schema
  checkouts: {
    keyPath: "id",
    autoIncrement: true,
    indexes: [
      { name: "employeeId", keyPath: "employeeId", unique: false },
      { name: "syncStatus", keyPath: "syncStatus", unique: false },
      {
        name: "localFormDetailId",
        keyPath: "localFormDetailId",
        unique: false,
      },
      {
        name: "serverFormDetailId",
        keyPath: "serverFormDetailId",
        unique: false,
      },
      { name: "createdAt", keyPath: "createdAt", unique: false },
    ],
    structure: {
      id: "auto-generated",
      employeeId: "number",
      localFormDetailId: "number", // Link to local form submission
      serverFormDetailId: "number|null", // Link to server form ID (null if not synced)
      checkoutLatitude: "string",
      checkoutLongitude: "string",
      checkoutTime: "string", // ISO string
      syncStatus: "string", // 'pending', 'syncing', 'synced', 'failed'
      retryCount: "number",
      lastError: "string|null",
      createdAt: "string", // ISO string
      updatedAt: "string", // ISO string
      serverResponseData: "object|null", // Store server response when synced
    },
  },

  // Sync queue item structure
  // syncQueueItem: {
  //   // id is auto-generated by IndexedDB
  //   type: null, // 'checkin', 'form', 'checkout', 'image'
  //   dataId: null, // Reference to the actual data record
  //   priority: 1, // 1 = high, 2 = medium, 3 = low
  //   status: "pending", // 'pending', 'processing', 'completed', 'failed'
  //   timestamp: null,
  //   retryCount: 0,
  //   lastAttempt: null,
  //   lastError: null,
  // },
  // Update sync queue to handle checkout operations
  syncQueue: {
    keyPath: "id",
    autoIncrement: true,
    indexes: [
      { name: "type", keyPath: "type", unique: false },
      { name: "priority", keyPath: "priority", unique: false },
      { name: "status", keyPath: "status", unique: false },
      { name: "dataId", keyPath: "dataId", unique: false },
    ],
    structure: {
      id: "auto-generated",
      type: "string", // 'form', 'image', 'checkout'
      dataId: "number", // ID of the data to sync
      priority: "number", // 1=high, 2=medium, 3=low
      status: "string", // 'pending', 'processing', 'completed', 'failed'
      createdAt: "string",
      lastAttempt: "string|null",
      retryCount: "number",
      dependsOn: "array|null", // Array of sync item IDs this depends on
    },
  },
};

// utils/networkUtils.js
export class NetworkUtils {
  static isOnline() {
    return navigator.onLine;
  }

  static async checkConnectivity() {
    if (!navigator.onLine) {
      return { isOnline: false, isSlowNetwork: false };
    }

    try {
      // Test with a small request to your server
      const startTime = Date.now();
      const response = await fetch("/api/health-check", {
        method: "HEAD",
        cache: "no-cache",
        timeout: 5000,
      });
      const endTime = Date.now();
      const responseTime = endTime - startTime;

      const isOnline = response.ok;
      const isSlowNetwork = responseTime > 3000; // Consider >3s as slow

      return { isOnline, isSlowNetwork, responseTime };
    } catch (error) {
      // If fetch fails, we're likely offline or have very poor connectivity
      return { isOnline: false, isSlowNetwork: true, error: error.message };
    }
  }

  static addNetworkListeners(callbacks) {
    const handleOnline = () => {
      console.log("Network: Online");
      if (callbacks.onOnline) callbacks.onOnline();
    };

    const handleOffline = () => {
      console.log("Network: Offline");
      if (callbacks.onOffline) callbacks.onOffline();
    };

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    // Return cleanup function
    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }

  static async testServerConnection(baseURL) {
    try {
      const response = await fetch(`${baseURL}/health`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
        timeout: 5000,
      });
      return response.ok;
    } catch (error) {
      console.error("Server connection test failed:", error);
      return false;
    }
  }
}

// utils/syncUtils.js
export class SyncUtils {
  static generateRetryDelay(retryCount) {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s
    const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
    // Add some jitter to avoid thundering herd
    const jitter = Math.random() * 1000;
    return delay + jitter;
  }

  static shouldRetry(retryCount, maxRetries = 5) {
    return retryCount < maxRetries;
  }

  static createSyncQueueItem(type, dataId, priority = 2) {
    return {
      type,
      dataId,
      priority,
      status: "pending",
      timestamp: new Date().toISOString(),
      retryCount: 0,
      lastAttempt: null,
      lastError: null,
    };
  }

  static isSyncable(item) {
    return item.syncStatus === "pending" || item.syncStatus === "failed";
  }

  static markAsSyncing(item) {
    return {
      ...item,
      syncStatus: "syncing",
      lastAttempt: new Date().toISOString(),
    };
  }

  static markAsSynced(item, serverResponse = {}) {
    return {
      ...item,
      syncStatus: "synced",
      lastError: null,
      ...serverResponse, // Merge any server-returned data
    };
  }

  static markAsFailed(item, error) {
    return {
      ...item,
      syncStatus: "failed",
      retryCount: item.retryCount + 1,
      lastError: error.message || "Unknown error",
      lastAttempt: new Date().toISOString(),
    };
  }
}

// utils/storageUtils.js
export class StorageUtils {
  static async convertFileToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  static async convertBase64ToFile(base64Data, fileName, fileType) {
    const response = await fetch(base64Data);
    const blob = await response.blob();
    return new File([blob], fileName, { type: fileType });
  }

  static calculateStorageUsage() {
    if ("storage" in navigator && "estimate" in navigator.storage) {
      return navigator.storage.estimate();
    }
    return null;
  }

  static async clearOldData(daysOld = 7) {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    const cutoffTimestamp = cutoffDate.toISOString();

    // This would be implemented to clean up old synced data
    console.log(`Cleaning up data older than ${cutoffTimestamp}`);
  }
}

// Checkout utility functions
export const CheckoutUtils = {
  // Create checkout data for offline storage
  createOfflineCheckout: (employeeId, formDetailId, coordinates) => {
    const now = new Date().toISOString();
    return {
      employeeId: employeeId,
      localFormDetailId: formDetailId, // Local form ID
      serverFormDetailId: null, // Will be updated when form syncs
      checkoutLatitude: coordinates.latitude,
      checkoutLongitude: coordinates.longitude,
      checkoutTime: now,
      syncStatus: "pending",
      retryCount: 0,
      lastError: null,
      createdAt: now,
      updatedAt: now,
      serverResponseData: null,
    };
  },

  // Mark checkout as syncing
  markAsSyncing: (checkout) => {
    return {
      ...checkout,
      syncStatus: "syncing",
      updatedAt: new Date().toISOString(),
    };
  },

  // Mark checkout as synced
  markAsSynced: (checkout, serverResponse = null) => {
    return {
      ...checkout,
      syncStatus: "synced",
      serverResponseData: serverResponse,
      updatedAt: new Date().toISOString(),
    };
  },

  // Mark checkout as failed
  markAsFailed: (checkout, error) => {
    return {
      ...checkout,
      syncStatus: "failed",
      retryCount: checkout.retryCount + 1,
      lastError: error.message || "Unknown error",
      updatedAt: new Date().toISOString(),
    };
  },

  // Check if checkout should be retried
  shouldRetry: (retryCount, maxRetries = 5) => {
    return retryCount < maxRetries;
  },

  // Get display status for checkout
  getDisplayStatus: (checkout) => {
    switch (checkout.syncStatus) {
      case "pending":
        return { text: "Pending sync", color: "text-yellow-600" };
      case "syncing":
        return { text: "Syncing...", color: "text-blue-600" };
      case "synced":
        return { text: "Synced", color: "text-green-600" };
      case "failed":
        return { text: "Sync failed", color: "text-red-600" };
      default:
        return { text: "Unknown", color: "text-gray-600" };
    }
  },
};
